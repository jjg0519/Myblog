<!DOCTYPE html><html><head><title>彻底理解ThreadLocal</title><meta charset='utf-8'><link href='https://dn-maxiang.qbox.me/res-min/themes/marxico.css' rel='stylesheet'><style>
.note-content  {font-family: 'Helvetica Neue', Arial, 'Hiragino Sans GB', STHeiti, 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, Song, sans-serif;}

</style></head><body><div id='preview-contents' class='note-content'>
                        <div id="wmd-preview" class="preview-content"></div>
                    <div id="wmd-preview-section-3301" class="wmd-preview-section preview-content">

</div><div id="wmd-preview-section-3302" class="wmd-preview-section preview-content">

<h1 id="彻底理解threadlocal">彻底理解ThreadLocal</h1>

<div><div class="toc"><div class="toc">
<ul>
<li><a href="#彻底理解threadlocal">彻底理解ThreadLocal</a></li>
</ul>
</div>
</div>
</div>

<p>ThreadLocal是什么 <br>
　　早在JDK 1.2的版本中就提供Java.lang.ThreadLocal，ThreadLocal为解决多线程程序的并发问题提供了一种新的思路。使用这个工具类可以很简洁地编写出优美的多线程程序。 <br>
　　当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。 <br>
　　从线程的角度看，目标变量就象是线程的本地变量，这也是类名中“Local”所要表达的意思。 <br>
　　所以，在Java中编写线程局部变量的代码相对来说要笨拙一些，因此造成线程局部变量没有在Java开发者中得到很好的普及。 <br>
ThreadLocal的接口方法 <br>
ThreadLocal类接口很简单，只有4个方法，我们先来了解一下： <br>
void set(Object value)设置当前线程的线程局部变量的值。 <br>
public Object get()该方法返回当前线程所对应的线程局部变量。 <br>
public void remove()将当前线程局部变量的值删除，目的是为了减少内存的占用，该方法是JDK 5.0新增的方法。需要指出的是，当线程结束后，对应该线程的局部变量将自动被垃圾回收，所以显式调用该方法清除线程的局部变量并不是必须的操作，但它可以加快内存回收的速度。 <br>
protected Object initialValue()返回该线程局部变量的初始值，该方法是一个protected的方法，显然是为了让子类覆盖而设计的。这个方法是一个延迟调用方法，在线程第1次调用get()或set(Object)时才执行，并且仅执行1次。ThreadLocal中的缺省实现直接返回一个null。 <br>
　　值得一提的是，在JDK5.0中，ThreadLocal已经支持泛型，该类的类名已经变为ThreadLocal。API方法也相应进行了调整，新版本的API方法分别是void set(T value)、T get()以及T initialValue()。 <br>
　　ThreadLocal是如何做到为每一个线程维护变量的副本的呢？其实实现的思路很简单：在ThreadLocal类中有一个Map，用于存储每一个线程的变量副本，Map中元素的键为线程对象，而值对应线程的变量副本。我们自己就可以提供一个简单的实现版本： <br>
在CODE上查看代码片派生到我的代码片</p>

</div><div id="wmd-preview-section-3303" class="wmd-preview-section preview-content">

<pre class="prettyprint with-line-number hljs-dark"><code class="language-java hljs"><span class="hljs-comment line-number">1.</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestNum</span> </span>{<br><span class="hljs-comment line-number">2.</span><span class="hljs-comment">// ①通过匿名内部类覆盖ThreadLocal的initialValue()方法，指定初始值</span><br><span class="hljs-comment line-number">3.</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;Integer&gt; seqNum = <span class="hljs-keyword">new</span> ThreadLocal&lt;Integer&gt;() {<br><span class="hljs-comment line-number">4.</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">initialValue</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-comment line-number">5.</span>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment line-number">6.</span>        }<br><span class="hljs-comment line-number">7.</span>    };<br><span class="hljs-comment line-number">8.</span><span class="hljs-comment">// ②获取下一个序列值</span><br><span class="hljs-comment line-number">9.</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNextNum</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-comment line-number">10.</span>        seqNum.set(seqNum.get() + <span class="hljs-number">1</span>);<br><span class="hljs-comment line-number">11.</span>        <span class="hljs-keyword">return</span> seqNum.get();<br><span class="hljs-comment line-number">12.</span>    }<br><span class="hljs-comment line-number">13.</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<br><span class="hljs-comment line-number">14.</span>        TestNum sn = <span class="hljs-keyword">new</span> TestNum();<br><span class="hljs-comment line-number">15.</span><span class="hljs-comment">// ③ 3个线程共享sn，各自产生序列号</span><br><span class="hljs-comment line-number">16.</span>        TestClient t1 = <span class="hljs-keyword">new</span> TestClient(sn);<br><span class="hljs-comment line-number">17.</span>        TestClient t2 = <span class="hljs-keyword">new</span> TestClient(sn);<br><span class="hljs-comment line-number">18.</span>        TestClient t3 = <span class="hljs-keyword">new</span> TestClient(sn);<br><span class="hljs-comment line-number">19.</span>        t1.start();<br><span class="hljs-comment line-number">20.</span>        t2.start();<br><span class="hljs-comment line-number">21.</span>        t3.start();<br><span class="hljs-comment line-number">22.</span>    }<br><span class="hljs-comment line-number">23.</span><br><span class="hljs-comment line-number">24.</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestClient</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>{<br><span class="hljs-comment line-number">25.</span>        <span class="hljs-keyword">private</span> TestNum sn;<br><span class="hljs-comment line-number">26.</span><br><span class="hljs-comment line-number">27.</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TestClient</span><span class="hljs-params">(TestNum sn)</span> </span>{<br><span class="hljs-comment line-number">28.</span>            <span class="hljs-keyword">this</span>.sn = sn;<br><span class="hljs-comment line-number">29.</span>        }<br><span class="hljs-comment line-number">30.</span><br><span class="hljs-comment line-number">31.</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-comment line-number">32.</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) {<br><span class="hljs-comment line-number">33.</span><span class="hljs-comment">// ④每个线程打出3个序列值</span><br><span class="hljs-comment line-number">34.</span>                System.out.println(<span class="hljs-string">"thread["</span> + Thread.currentThread().getName() + <span class="hljs-string">"] --&gt; sn["</span><br><span class="hljs-comment line-number">35.</span>                                   + sn.getNextNum() + <span class="hljs-string">"]"</span>);<br><span class="hljs-comment line-number">36.</span>            }<br><span class="hljs-comment line-number">37.</span>        }<br><span class="hljs-comment line-number">38.</span>    }<br><span class="hljs-comment line-number">39.</span>}<br></code></pre>

<p>通常我们通过匿名内部类的方式定义ThreadLocal的子类，提供初始的变量值，如例子中①处所示。TestClient线程产生一组序列号，在③处，我们生成3个TestClient，它们共享同一个TestNum实例。运行以上代码，在控制台上输出以下的结果：</p>

</div><div id="wmd-preview-section-3304" class="wmd-preview-section preview-content">

<pre class="prettyprint with-line-number hljs-dark"><code class="language-bash hljs"><span class="hljs-comment line-number">1.</span>tread[Thread-<span class="hljs-number">0</span>] --&gt; sn[<span class="hljs-number">1</span>]<br><span class="hljs-comment line-number">2.</span>thread[Thread-<span class="hljs-number">1</span>] --&gt; sn[<span class="hljs-number">1</span>]<br><span class="hljs-comment line-number">3.</span>thread[Thread-<span class="hljs-number">2</span>] --&gt; sn[<span class="hljs-number">1</span>]<br><span class="hljs-comment line-number">4.</span>thread[Thread-<span class="hljs-number">1</span>] --&gt; sn[<span class="hljs-number">2</span>]<br><span class="hljs-comment line-number">5.</span>thread[Thread-<span class="hljs-number">0</span>] --&gt; sn[<span class="hljs-number">2</span>]<br><span class="hljs-comment line-number">6.</span>thread[Thread-<span class="hljs-number">1</span>] --&gt; sn[<span class="hljs-number">3</span>]<br><span class="hljs-comment line-number">7.</span>thread[Thread-<span class="hljs-number">2</span>] --&gt; sn[<span class="hljs-number">2</span>]<br><span class="hljs-comment line-number">8.</span>thread[Thread-<span class="hljs-number">0</span>] --&gt; sn[<span class="hljs-number">3</span>]<br><span class="hljs-comment line-number">9.</span>thread[Thread-<span class="hljs-number">2</span>] --&gt; sn[<span class="hljs-number">3</span>]<br></code></pre>

<p>考察输出的结果信息，我们发现每个线程所产生的序号虽然都共享同一个TestNum实例，但它们并没有发生相互干扰的情况，而是各自产生独立的序列号，这是因为我们通过ThreadLocal为每一个线程提供了单独的副本。</p>

<p>Thread同步机制的比较 <br>
　　ThreadLocal和线程同步机制相比有什么优势呢？ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。 <br>
　　在同步机制中，通过对象的锁机制保证同一时间只有一个线程访问变量。这时该变量是多个线程共享的，使用同步机制要求程序慎密地分析什么时候对变量进行读写，什么时候需要锁定某个对象，什么时候释放对象锁等繁杂的问题，程序设计和编写难度相对较大。 <br>
　　而ThreadLocal则从另一个角度来解决多线程的并发访问。ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。 <br>
　　由于ThreadLocal中可以持有任何类型的对象，低版本JDK所提供的get()返回的是Object对象，需要强制类型转换。但JDK 5.0通过泛型很好的解决了这个问题，在一定程度地简化ThreadLocal的使用，代码清单 9 2就使用了JDK 5.0新的ThreadLocal版本。 <br>
　　概括起来说，对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式。前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。 <br>
　　spring使用ThreadLocal解决线程安全问题我们知道在一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域。就是因为Spring对一些Bean（如RequestContextHolder、TransactionSynchronizationManager、LocaleContextHolder等）中非线程安全状态采用ThreadLocal进行处理，让它们也成为线程安全的状态，因为有状态的Bean就可以在多线程中共享了。 <br>
　　一般的Web应用划分为展现层、服务层和持久层三个层次，在不同的层中编写对应的逻辑，下层通过接口向上层开放功能调用。在一般情况下，从接收请求到返回响应所经过的所有程序调用都同属于一个线程，如图9‑2所示： <br>
通通透透理解ThreadLocal <br>
　　同一线程贯通三层这样你就可以根据需要，将一些非线程安全的变量以ThreadLocal存放，在同一次请求响应的调用线程中，所有关联的对象引用到的都是同一个变量。 <br>
　　下面的实例能够体现Spring对有状态Bean的改造思路： <br>
代码清单3 TestDao：非线程安全 <br>
[java] view plain copy print?在CODE上查看代码片派生到我的代码片</p>

</div><div id="wmd-preview-section-3305" class="wmd-preview-section preview-content">

<pre class="prettyprint with-line-number hljs-dark"><code class="language-java hljs"><span class="hljs-comment line-number">1.</span><span class="hljs-keyword">package</span> com.test;    <br><span class="hljs-comment line-number">2.</span><span class="hljs-keyword">import</span> java.sql.Connection;  <br><span class="hljs-comment line-number">3.</span><span class="hljs-keyword">import</span> java.sql.SQLException;  <br><span class="hljs-comment line-number">4.</span><span class="hljs-keyword">import</span> java.sql.Statement;  <br><span class="hljs-comment line-number">5.</span><br><span class="hljs-comment line-number">6.</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestDao</span> </span>{  <br><span class="hljs-comment line-number">7.</span>    <span class="hljs-keyword">private</span> Connection conn;<span class="hljs-comment">// ①一个非线程安全的变量  </span><br><span class="hljs-comment line-number">8.</span><br><span class="hljs-comment line-number">9.</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addTopic</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>{  <br><span class="hljs-comment line-number">10.</span>        Statement stat = conn.createStatement();<span class="hljs-comment">// ②引用非线程安全变量  </span><br><span class="hljs-comment line-number">11.</span>        <span class="hljs-comment">// …  </span><br><span class="hljs-comment line-number">12.</span>    }  <br><span class="hljs-comment line-number">13.</span>}  <br></code></pre>

<p>由于①处的conn是成员变量，因为addTopic()方法是非线程安全的，必须在使用时创建一个新TopicDao实例（非singleton）。下面使用ThreadLocal对conn这个非线程安全的“状态”进行改造： <br>
代码清单4 TestDao：线程安全 <br>
[java] view plain copy print?在CODE上查看代码片派生到我的代码片</p>

</div><div id="wmd-preview-section-3306" class="wmd-preview-section preview-content">

<pre class="prettyprint with-line-number hljs-dark"><code class="language-java hljs"><span class="hljs-comment line-number">1.</span><span class="hljs-keyword">package</span> com.test;  <br><span class="hljs-comment line-number">2.</span><br><span class="hljs-comment line-number">3.</span><span class="hljs-keyword">import</span> java.sql.Connection;  <br><span class="hljs-comment line-number">4.</span><span class="hljs-keyword">import</span> java.sql.SQLException;  <br><span class="hljs-comment line-number">5.</span><span class="hljs-keyword">import</span> java.sql.Statement;  <br><span class="hljs-comment line-number">6.</span><br><span class="hljs-comment line-number">7.</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestDaoNew</span> </span>{  <br><span class="hljs-comment line-number">8.</span>    <span class="hljs-comment">// ①使用ThreadLocal保存Connection变量  </span><br><span class="hljs-comment line-number">9.</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;Connection&gt; connThreadLocal = <span class="hljs-keyword">new</span> ThreadLocal&lt;Connection&gt;();  <br><span class="hljs-comment line-number">10.</span><br><span class="hljs-comment line-number">11.</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> </span>{  <br><span class="hljs-comment line-number">12.</span>        <span class="hljs-comment">// ②如果connThreadLocal没有本线程对应的Connection创建一个新的Connection，  </span><br><span class="hljs-comment line-number">13.</span>        <span class="hljs-comment">// 并将其保存到线程本地变量中。  </span><br><span class="hljs-comment line-number">14.</span>        <span class="hljs-keyword">if</span> (connThreadLocal.get() == <span class="hljs-keyword">null</span>) {  <br><span class="hljs-comment line-number">15.</span>            Connection conn = getConnection();  <br><span class="hljs-comment line-number">16.</span>            connThreadLocal.set(conn);  <br><span class="hljs-comment line-number">17.</span>            <span class="hljs-keyword">return</span> conn;  <br><span class="hljs-comment line-number">18.</span>        } <span class="hljs-keyword">else</span> {  <br><span class="hljs-comment line-number">19.</span>            <span class="hljs-keyword">return</span> connThreadLocal.get();<span class="hljs-comment">// ③直接返回线程本地变量  </span><br><span class="hljs-comment line-number">20.</span>        }  <br><span class="hljs-comment line-number">21.</span>    }  <br><span class="hljs-comment line-number">22.</span><br><span class="hljs-comment line-number">23.</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addTopic</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>{  <br><span class="hljs-comment line-number">24.</span>        <span class="hljs-comment">// ④从ThreadLocal中获取线程对应的Connection  </span><br><span class="hljs-comment line-number">25.</span>        Statement stat = getConnection().createStatement();  <br><span class="hljs-comment line-number">26.</span>    }  <br><span class="hljs-comment line-number">27.</span>}  <br></code></pre>

<p>　　不同的线程在使用TopicDao时，先判断connThreadLocal.get()是否是null，如果是null，则说明当前线程还没有对应的Connection对象，这时创建一个Connection对象并添加到本地线程变量中；如果不为null，则说明当前的线程已经拥有了Connection对象，直接使用就可以了。这样，就保证了不同的线程使用线程相关的Connection，而不会使用其它线程的Connection。因此，这个TopicDao就可以做到singleton共享了。 <br>
　　当然，这个例子本身很粗糙，将Connection的ThreadLocal直接放在DAO只能做到本DAO的多个方法共享Connection时不发生线程安全问题，但无法和其它DAO共用同一个Connection，要做到同一事务多DAO共享同一Connection，必须在一个共同的外部类使用ThreadLocal保存Connection。</p>

<p>ConnectionManager.java <br>
[java] view plain copy print?在CODE上查看代码片派生到我的代码片</p>

</div><div id="wmd-preview-section-3307" class="wmd-preview-section preview-content">

<pre class="prettyprint with-line-number hljs-dark"><code class="language-java hljs"><span class="hljs-comment line-number">1.</span><span class="hljs-keyword">package</span> com.test;  <br><span class="hljs-comment line-number">2.</span><br><span class="hljs-comment line-number">3.</span><span class="hljs-keyword">import</span> java.sql.Connection;  <br><span class="hljs-comment line-number">4.</span><span class="hljs-keyword">import</span> java.sql.DriverManager;  <br><span class="hljs-comment line-number">5.</span><span class="hljs-keyword">import</span> java.sql.SQLException;  <br><span class="hljs-comment line-number">6.</span><br><span class="hljs-comment line-number">7.</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectionManager</span> </span>{  <br><span class="hljs-comment line-number">8.</span><br><span class="hljs-comment line-number">9.</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;Connection&gt; connectionHolder = <span class="hljs-keyword">new</span> ThreadLocal&lt;Connection&gt;() {  <br><span class="hljs-comment line-number">10.</span>        <span class="hljs-annotation">@Override</span>  <br><span class="hljs-comment line-number">11.</span>        <span class="hljs-function"><span class="hljs-keyword">protected</span> Connection <span class="hljs-title">initialValue</span><span class="hljs-params">()</span> </span>{  <br><span class="hljs-comment line-number">12.</span>            Connection conn = <span class="hljs-keyword">null</span>;  <br><span class="hljs-comment line-number">13.</span>            <span class="hljs-keyword">try</span> {  <br><span class="hljs-comment line-number">14.</span>                conn = DriverManager.getConnection(  <br><span class="hljs-comment line-number">15.</span>                        <span class="hljs-string">"jdbc:mysql://localhost:3306/test"</span>, <span class="hljs-string">"username"</span>,  <br><span class="hljs-comment line-number">16.</span>                        <span class="hljs-string">"password"</span>);  <br><span class="hljs-comment line-number">17.</span>            } <span class="hljs-keyword">catch</span> (SQLException e) {  <br><span class="hljs-comment line-number">18.</span>                e.printStackTrace();  <br><span class="hljs-comment line-number">19.</span>            }  <br><span class="hljs-comment line-number">20.</span>            <span class="hljs-keyword">return</span> conn;  <br><span class="hljs-comment line-number">21.</span>        }  <br><span class="hljs-comment line-number">22.</span>    };  <br><span class="hljs-comment line-number">23.</span><br><span class="hljs-comment line-number">24.</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> </span>{  <br><span class="hljs-comment line-number">25.</span>        <span class="hljs-keyword">return</span> connectionHolder.get();  <br><span class="hljs-comment line-number">26.</span>    }  <br><span class="hljs-comment line-number">27.</span><br><span class="hljs-comment line-number">28.</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setConnection</span><span class="hljs-params">(Connection conn)</span> </span>{  <br><span class="hljs-comment line-number">29.</span>        connectionHolder.set(conn);  <br><span class="hljs-comment line-number">30.</span>    }  <br><span class="hljs-comment line-number">31.</span>}  <br></code></pre>

<p>java.lang.ThreadLocal的具体实现 <br>
那么到底ThreadLocal类是如何实现这种“为每个线程提供不同的变量拷贝”的呢？先来看一下ThreadLocal的set()方法的源码是如何实现的：</p>

</div><div id="wmd-preview-section-3308" class="wmd-preview-section preview-content">

<pre class="prettyprint with-line-number hljs-dark"><code class="language-java hljs"><span class="hljs-comment line-number">1.</span>[java] view plain copy print?在CODE上查看代码片派生到我的代码片<br><span class="hljs-comment line-number">2.</span><span class="hljs-comment">/** <br><span class="hljs-comment line-number">3.</span>    * Sets the current thread's copy of this thread-local variable <br><span class="hljs-comment line-number">4.</span>    * to the specified value.  Most subclasses will have no need to <br><span class="hljs-comment line-number">5.</span>    * override this method, relying solely on the {<span class="hljs-doctag">@link</span> #initialValue} <br><span class="hljs-comment line-number">6.</span>    * method to set the values of thread-locals. <br><span class="hljs-comment line-number">7.</span>    * <br><span class="hljs-comment line-number">8.</span>    * <span class="hljs-doctag">@param</span> value the value to be stored in the current thread's copy of <br><span class="hljs-comment line-number">9.</span>    *        this thread-local. <br><span class="hljs-comment line-number">10.</span>    */</span>  <br><span class="hljs-comment line-number">11.</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(T value)</span> </span>{  <br><span class="hljs-comment line-number">12.</span>       Thread t = Thread.currentThread();  <br><span class="hljs-comment line-number">13.</span>       ThreadLocalMap map = getMap(t);  <br><span class="hljs-comment line-number">14.</span>       <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>)  <br><span class="hljs-comment line-number">15.</span>           map.set(<span class="hljs-keyword">this</span>, value);  <br><span class="hljs-comment line-number">16.</span>       <span class="hljs-keyword">else</span>  <br><span class="hljs-comment line-number">17.</span>           createMap(t, value);  <br><span class="hljs-comment line-number">18.</span>   }  <br></code></pre>

<p>在这个方法内部我们看到，首先通过getMap(Thread t)方法获取一个和当前线程相关的ThreadLocalMap，然后将变量的值设置到这个ThreadLocalMap对象中，当然如果获取到的ThreadLocalMap对象为空，就通过createMap方法创建。</p>

<p>线程隔离的秘密，就在于ThreadLocalMap这个类。ThreadLocalMap是ThreadLocal类的一个静态内部类，它实现了键值对的设置和获取（对比Map对象来理解），每个线程中都有一个独立的ThreadLocalMap副本，它所存储的值，只能被当前线程读取和修改。ThreadLocal类通过操作每一个线程特有的ThreadLocalMap副本，从而实现了变量访问在不同线程中的隔离。因为每个线程的变量都是自己特有的，完全不会有并发错误。还有一点就是，ThreadLocalMap存储的键值对中的键是this对象指向的ThreadLocal对象，而值就是你所设置的对象了。</p>

<p>为了加深理解，我们接着看上面代码中出现的getMap和createMap方法的实现： <br>
[java] view plain copy print?在CODE上查看代码片派生到我的代码片</p>

</div><div id="wmd-preview-section-3309" class="wmd-preview-section preview-content">

<pre class="prettyprint with-line-number hljs-dark"><code class="language-java hljs"><span class="hljs-comment line-number">1.</span><span class="hljs-comment">/** <br><span class="hljs-comment line-number">2.</span> * Get the map associated with a ThreadLocal. Overridden in <br><span class="hljs-comment line-number">3.</span> * InheritableThreadLocal. <br><span class="hljs-comment line-number">4.</span> * <br><span class="hljs-comment line-number">5.</span> * <span class="hljs-doctag">@param</span>  t the current thread <br><span class="hljs-comment line-number">6.</span> * <span class="hljs-doctag">@return</span> the map <br><span class="hljs-comment line-number">7.</span> */</span>  <br><span class="hljs-comment line-number">8.</span><span class="hljs-function">ThreadLocalMap <span class="hljs-title">getMap</span><span class="hljs-params">(Thread t)</span> </span>{  <br><span class="hljs-comment line-number">9.</span>    <span class="hljs-keyword">return</span> t.threadLocals;  <br><span class="hljs-comment line-number">10.</span>}  <br><span class="hljs-comment line-number">11.</span><br><span class="hljs-comment line-number">12.</span><span class="hljs-comment">/** <br><span class="hljs-comment line-number">13.</span> * Create the map associated with a ThreadLocal. Overridden in <br><span class="hljs-comment line-number">14.</span> * InheritableThreadLocal. <br><span class="hljs-comment line-number">15.</span> * <br><span class="hljs-comment line-number">16.</span> * <span class="hljs-doctag">@param</span> t the current thread <br><span class="hljs-comment line-number">17.</span> * <span class="hljs-doctag">@param</span> firstValue value for the initial entry of the map <br><span class="hljs-comment line-number">18.</span> * <span class="hljs-doctag">@param</span> map the map to store. <br><span class="hljs-comment line-number">19.</span> */</span>  <br><span class="hljs-comment line-number">20.</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> </span>{  <br><span class="hljs-comment line-number">21.</span>    t.threadLocals = <span class="hljs-keyword">new</span> ThreadLocalMap(<span class="hljs-keyword">this</span>, firstValue);  <br><span class="hljs-comment line-number">22.</span>}  <br></code></pre>

<p>接下来再看一下ThreadLocal类中的get()方法: <br>
[java] view plain copy print?在CODE上查看代码片派生到我的代码片</p>

</div><div id="wmd-preview-section-3310" class="wmd-preview-section preview-content">

<pre class="prettyprint with-line-number hljs-dark"><code class="language-java hljs"><span class="hljs-comment line-number">1.</span><span class="hljs-comment">/** <br><span class="hljs-comment line-number">2.</span> * Returns the value in the current thread's copy of this <br><span class="hljs-comment line-number">3.</span> * thread-local variable.  If the variable has no value for the <br><span class="hljs-comment line-number">4.</span> * current thread, it is first initialized to the value returned <br><span class="hljs-comment line-number">5.</span> * by an invocation of the {<span class="hljs-doctag">@link</span> #initialValue} method. <br><span class="hljs-comment line-number">6.</span> * <br><span class="hljs-comment line-number">7.</span> * <span class="hljs-doctag">@return</span> the current thread's value of this thread-local <br><span class="hljs-comment line-number">8.</span> */</span>  <br><span class="hljs-comment line-number">9.</span><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>{  <br><span class="hljs-comment line-number">10.</span>    Thread t = Thread.currentThread();  <br><span class="hljs-comment line-number">11.</span>    ThreadLocalMap map = getMap(t);  <br><span class="hljs-comment line-number">12.</span>    <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>) {  <br><span class="hljs-comment line-number">13.</span>        ThreadLocalMap.Entry e = map.getEntry(<span class="hljs-keyword">this</span>);  <br><span class="hljs-comment line-number">14.</span>        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>)  <br><span class="hljs-comment line-number">15.</span>            <span class="hljs-keyword">return</span> (T)e.value;  <br><span class="hljs-comment line-number">16.</span>    }  <br><span class="hljs-comment line-number">17.</span>    <span class="hljs-keyword">return</span> setInitialValue();  <br><span class="hljs-comment line-number">18.</span>}  <br></code></pre>

<p>再来看setInitialValue()方法： <br>
[java] view plain copy print?在CODE上查看代码片派生到我的代码片</p>

</div><div id="wmd-preview-section-3311" class="wmd-preview-section preview-content">

<pre class="prettyprint with-line-number hljs-dark"><code class="language-java hljs"><span class="hljs-comment line-number">1.</span><span class="hljs-comment">/** <br><span class="hljs-comment line-number">2.</span>    * Variant of set() to establish initialValue. Used instead <br><span class="hljs-comment line-number">3.</span>    * of set() in case user has overridden the set() method. <br><span class="hljs-comment line-number">4.</span>    * <br><span class="hljs-comment line-number">5.</span>    * <span class="hljs-doctag">@return</span> the initial value <br><span class="hljs-comment line-number">6.</span>    */</span>  <br><span class="hljs-comment line-number">7.</span>   <span class="hljs-function"><span class="hljs-keyword">private</span> T <span class="hljs-title">setInitialValue</span><span class="hljs-params">()</span> </span>{  <br><span class="hljs-comment line-number">8.</span>       T value = initialValue();  <br><span class="hljs-comment line-number">9.</span>       Thread t = Thread.currentThread();  <br><span class="hljs-comment line-number">10.</span>       ThreadLocalMap map = getMap(t);  <br><span class="hljs-comment line-number">11.</span>       <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>)  <br><span class="hljs-comment line-number">12.</span>           map.set(<span class="hljs-keyword">this</span>, value);  <br><span class="hljs-comment line-number">13.</span>       <span class="hljs-keyword">else</span>  <br><span class="hljs-comment line-number">14.</span>           createMap(t, value);  <br><span class="hljs-comment line-number">15.</span>       <span class="hljs-keyword">return</span> value;  <br><span class="hljs-comment line-number">16.</span>   }  <br></code></pre>

<p>　　获取和当前线程绑定的值时，ThreadLocalMap对象是以this指向的ThreadLocal对象为键进行查找的，这当然和前面set()方法的代码是相呼应的。</p>

<p>　　进一步地，我们可以创建不同的ThreadLocal实例来实现多个变量在不同线程间的访问隔离，为什么可以这么做？因为不同的ThreadLocal对象作为不同键，当然也可以在线程的ThreadLocalMap对象中设置不同的值了。通过ThreadLocal对象，在多线程中共享一个值和多个值的区别，就像你在一个HashMap对象中存储一个键值对和多个键值对一样，仅此而已。</p>

<p>小结 <br>
　　ThreadLocal是解决线程安全问题一个很好的思路，它通过为每个线程提供一个独立的变量副本解决了变量并发访问的冲突问题。在很多情况下，ThreadLocal比直接使用synchronized同步机制解决线程安全问题更简单，更方便，且结果程序拥有更高的并发性。 <br>
ConnectionManager.java <br>
[java] view plain copy print?在CODE上查看代码片派生到我的代码片</p>

</div><div id="wmd-preview-section-3312" class="wmd-preview-section preview-content">

<pre class="prettyprint with-line-number hljs-dark"><code class="language-java hljs"><span class="hljs-comment line-number">1.</span><span class="hljs-keyword">package</span> com.test;  <br><span class="hljs-comment line-number">2.</span><br><span class="hljs-comment line-number">3.</span><span class="hljs-keyword">import</span> java.sql.Connection;  <br><span class="hljs-comment line-number">4.</span><span class="hljs-keyword">import</span> java.sql.DriverManager;  <br><span class="hljs-comment line-number">5.</span><span class="hljs-keyword">import</span> java.sql.SQLException;  <br><span class="hljs-comment line-number">6.</span><br><span class="hljs-comment line-number">7.</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConnectionManager</span> </span>{  <br><span class="hljs-comment line-number">8.</span><br><span class="hljs-comment line-number">9.</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;Connection&gt; connectionHolder = <span class="hljs-keyword">new</span> ThreadLocal&lt;Connection&gt;() {  <br><span class="hljs-comment line-number">10.</span>        <span class="hljs-annotation">@Override</span>  <br><span class="hljs-comment line-number">11.</span>        <span class="hljs-function"><span class="hljs-keyword">protected</span> Connection <span class="hljs-title">initialValue</span><span class="hljs-params">()</span> </span>{  <br><span class="hljs-comment line-number">12.</span>            Connection conn = <span class="hljs-keyword">null</span>;  <br><span class="hljs-comment line-number">13.</span>            <span class="hljs-keyword">try</span> {  <br><span class="hljs-comment line-number">14.</span>                conn = DriverManager.getConnection(  <br><span class="hljs-comment line-number">15.</span>                        <span class="hljs-string">"jdbc:mysql://localhost:3306/test"</span>, <span class="hljs-string">"username"</span>,  <br><span class="hljs-comment line-number">16.</span>                        <span class="hljs-string">"password"</span>);  <br><span class="hljs-comment line-number">17.</span>            } <span class="hljs-keyword">catch</span> (SQLException e) {  <br><span class="hljs-comment line-number">18.</span>                e.printStackTrace();  <br><span class="hljs-comment line-number">19.</span>            }  <br><span class="hljs-comment line-number">20.</span>            <span class="hljs-keyword">return</span> conn;  <br><span class="hljs-comment line-number">21.</span>        }  <br><span class="hljs-comment line-number">22.</span>    };  <br><span class="hljs-comment line-number">23.</span><br><span class="hljs-comment line-number">24.</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> </span>{  <br><span class="hljs-comment line-number">25.</span>        <span class="hljs-keyword">return</span> connectionHolder.get();  <br><span class="hljs-comment line-number">26.</span>    }  <br><span class="hljs-comment line-number">27.</span><br><span class="hljs-comment line-number">28.</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setConnection</span><span class="hljs-params">(Connection conn)</span> </span>{  <br><span class="hljs-comment line-number">29.</span>        connectionHolder.set(conn);  <br><span class="hljs-comment line-number">30.</span>    }  <br><span class="hljs-comment line-number">31.</span>}  <br></code></pre>

<p>后记 <br>
　　看到网友评论的很激烈，甚至关于ThreadLocalMap不是ThreadLocal里面的，而是Thread里面的这种评论都出现了，于是有了这个后记，下面先把jdk源码贴上，源码最有说服力了。 <br>
[java] view plain copy print?在CODE上查看代码片派生到我的代码片</p>

</div><div id="wmd-preview-section-3313" class="wmd-preview-section preview-content">

<pre class="prettyprint with-line-number hljs-dark"><code class="language-java hljs"><span class="hljs-comment line-number">1.</span><span class="hljs-comment">/** <br><span class="hljs-comment line-number">2.</span>     * ThreadLocalMap is a customized hash map suitable only for <br><span class="hljs-comment line-number">3.</span>     * maintaining thread local values. No operations are exported <br><span class="hljs-comment line-number">4.</span>     * outside of the ThreadLocal class. The class is package private to <br><span class="hljs-comment line-number">5.</span>     * allow declaration of fields in class Thread.  To help deal with <br><span class="hljs-comment line-number">6.</span>     * very large and long-lived usages, the hash table entries use <br><span class="hljs-comment line-number">7.</span>     * WeakReferences for keys. However, since reference queues are not <br><span class="hljs-comment line-number">8.</span>     * used, stale entries are guaranteed to be removed only when <br><span class="hljs-comment line-number">9.</span>     * the table starts running out of space. <br><span class="hljs-comment line-number">10.</span>     */</span>  <br><span class="hljs-comment line-number">11.</span>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocalMap</span> </span>{...}  <br></code></pre>

<p>　　源码就是以上，这源码自然是在ThreadLocal里面的，有截图为证。</p>

<p>　　本文是自己在学习ThreadLocal的时候，一时兴起，深入看了源码，思考了此类的作用、使用范围，进而联想到对传统的synchronize共享变量线程安全的问题进行比较，而总结的博文，总结一句话就是一个是锁机制进行时间换空间，一个是存储拷贝进行空间换时间。</p>

<p>(全文完)</p></div><div id="wmd-preview-section-footnotes" class="preview-content"></div></div></body></html>