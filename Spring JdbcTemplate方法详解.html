<!DOCTYPE html><html><head><title>Spring JdbcTemplate方法详解</title><meta charset='utf-8'><link href='https://dn-maxiang.qbox.me/res-min/themes/marxico.css' rel='stylesheet'><style>
.note-content  {font-family: 'Helvetica Neue', Arial, 'Hiragino Sans GB', STHeiti, 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, Song, sans-serif;}

</style></head><body><div id='preview-contents' class='note-content'>
                        <div id="wmd-preview" class="preview-content"></div>
                    <div id="wmd-preview-section-3091" class="wmd-preview-section preview-content">

</div><div id="wmd-preview-section-3092" class="wmd-preview-section preview-content">

<h1 id="spring-jdbctemplate方法详解">Spring JdbcTemplate方法详解</h1>

<p>JdbcTemplate主要提供以下五类方法：</p>

<ul><li><p>execute方法：</p>

<blockquote>
  <p>可以用于执行任何SQL语句，一般用于执行DDL语句；</p>
</blockquote></li>
<li><p>update方法及batchUpdate方法：</p>

<blockquote>
  <p>update方法用于执行新增、修改、删除等语句；batchUpdate方法用于执行批处理相关语句；</p>
</blockquote></li>
<li><p>query方法及queryForXXX方法：</p>

<blockquote>
  <p>用于执行查询相关语句；</p>
</blockquote></li>
<li><p>call方法</p>

<blockquote>
  <p>用于执行存储过程、函数相关语句。</p>
</blockquote></li>
</ul>

<hr>

<p>JdbcTemplate类支持的回调类： <br>
预编译语句及存储过程创建回调：用于根据JdbcTemplate提供的连接创建相应的语句；</p>

<p>PreparedStatementCreator：通过回调获取JdbcTemplate提供的Connection，由用户使用该Conncetion创建相关的PreparedStatement； <br>
CallableStatementCreator：通过回调获取JdbcTemplate提供的Connection，由用户使用该Conncetion创建相关的CallableStatement； <br>
预编译语句设值回调：用于给预编译语句相应参数设值；</p>

<p>PreparedStatementSetter：通过回调获取JdbcTemplate提供的PreparedStatement，由用户来对相应的预编译语句相应参数设值； <br>
BatchPreparedStatementSetter：；类似于PreparedStatementSetter，但用于批处理，需要指定批处理大小； <br>
自定义功能回调：提供给用户一个扩展点，用户可以在指定类型的扩展点执行任何数量需要的操作；</p>

<p>ConnectionCallback：通过回调获取JdbcTemplate提供的Connection，用户可在该Connection执行任何数量的操作； <br>
StatementCallback：通过回调获取JdbcTemplate提供的Statement，用户可以在该Statement执行任何数量的操作； <br>
PreparedStatementCallback：通过回调获取JdbcTemplate提供的PreparedStatement，用户可以在该PreparedStatement执行任何数量的操作； <br>
CallableStatementCallback：通过回调获取JdbcTemplate提供的CallableStatement，用户可以在该CallableStatement执行任何数量的操作； <br>
结果集处理回调：通过回调处理ResultSet或将ResultSet转换为需要的形式；</p>

<p>RowMapper：用于将结果集每行数据转换为需要的类型，用户需实现方法mapRow(ResultSet rs, int rowNum)来完成将每行数据转换为相应的类型。 <br>
RowCallbackHandler：用于处理ResultSet的每一行结果，用户需实现方法processRow(ResultSet rs)来完成处理，在该回调方法中无需执行rs.next()，该操作由JdbcTemplate来执行，用户只需按行获取数据然后处理即可。 <br>
ResultSetExtractor：用于结果集数据提取，用户需实现方法extractData(ResultSet rs)来处理结果集，用户必须处理整个结果集；</p>

<p>接下来让我们看下具体示例吧，在示例中不可能介绍到JdbcTemplate全部方法及回调类的使用方法，我们只介绍代表性的，其余的使用都是类似的；</p>

<p>1）预编译语句及存储过程创建回调、自定义功能回调使用：</p>

</div><div id="wmd-preview-section-3093" class="wmd-preview-section preview-content">

<pre class="prettyprint with-line-number hljs-dark"><code class="hljs aspectj"><span class="hljs-comment line-number">1.</span><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testPpreparedStatement1</span><span class="hljs-params">()</span> </span>{  <br><span class="hljs-comment line-number">2.</span>  <span class="hljs-keyword">int</span> count = jdbcTemplate.execute(<span class="hljs-keyword">new</span> PreparedStatementCreator() {  <br><span class="hljs-comment line-number">3.</span>     <span class="hljs-annotation">@Override</span>  <br><span class="hljs-comment line-number">4.</span>     <span class="hljs-keyword">public</span> <span class="hljs-function">PreparedStatement <span class="hljs-title">createPreparedStatement</span><span class="hljs-params">(Connection conn)</span>  <br><span class="hljs-comment line-number">5.</span>         <span class="hljs-keyword">throws</span> SQLException </span>{  <br><span class="hljs-comment line-number">6.</span>         <span class="hljs-keyword">return</span> conn.prepareStatement(<span class="hljs-string">"select count(*) from test"</span>);  <br><span class="hljs-comment line-number">7.</span>     }}, <span class="hljs-keyword">new</span> PreparedStatementCallback&lt;Integer&gt;() {  <br><span class="hljs-comment line-number">8.</span>     <span class="hljs-annotation">@Override</span>  <br><span class="hljs-comment line-number">9.</span>     <span class="hljs-keyword">public</span> <span class="hljs-function">Integer <span class="hljs-title">doInPreparedStatement</span><span class="hljs-params">(PreparedStatement pstmt)</span>  <br><span class="hljs-comment line-number">10.</span>         <span class="hljs-keyword">throws</span> SQLException, DataAccessException </span>{  <br><span class="hljs-comment line-number">11.</span>         pstmt.execute();  <br><span class="hljs-comment line-number">12.</span>         ResultSet rs = pstmt.getResultSet();  <br><span class="hljs-comment line-number">13.</span>         rs.next();  <br><span class="hljs-comment line-number">14.</span>         <span class="hljs-function"><span class="hljs-keyword">return</span> rs.<span class="hljs-title">getInt</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;  <br><span class="hljs-comment line-number">15.</span>      }});      <br><span class="hljs-comment line-number">16.</span>   Assert.assertEquals(<span class="hljs-number">0</span>, count);  <br><span class="hljs-comment line-number">17.</span>}  <br></code></pre>

<p>首先使用PreparedStatementCreator创建一个预编译语句，其次由JdbcTemplate通过PreparedStatementCallback回调传回，由用户决定如何执行该PreparedStatement。此处我们使用的是execute方法。</p>

<p>2）预编译语句设值回调使用：</p>

</div><div id="wmd-preview-section-3094" class="wmd-preview-section preview-content">

<pre class="prettyprint with-line-number hljs-dark"><code class="language-java hljs"><span class="hljs-comment line-number">1.</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testPreparedStatement2</span><span class="hljs-params">()</span> </span>{  <br><span class="hljs-comment line-number">2.</span>  String insertSql = <span class="hljs-string">"insert into test(name) values (?)"</span>;  <br><span class="hljs-comment line-number">3.</span>  <span class="hljs-keyword">int</span> count = jdbcTemplate.update(insertSql, <span class="hljs-keyword">new</span> PreparedStatementSetter() {  <br><span class="hljs-comment line-number">4.</span>      <span class="hljs-annotation">@Override</span>  <br><span class="hljs-comment line-number">5.</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setValues</span><span class="hljs-params">(PreparedStatement pstmt)</span> <span class="hljs-keyword">throws</span> SQLException </span>{  <br><span class="hljs-comment line-number">6.</span>          pstmt.setObject(<span class="hljs-number">1</span>, <span class="hljs-string">"name4"</span>);  <br><span class="hljs-comment line-number">7.</span>  }});  <br><span class="hljs-comment line-number">8.</span>  Assert.assertEquals(<span class="hljs-number">1</span>, count);      <br><span class="hljs-comment line-number">9.</span>  String deleteSql = <span class="hljs-string">"delete from test where name=?"</span>;  <br><span class="hljs-comment line-number">10.</span>  count = jdbcTemplate.update(deleteSql, <span class="hljs-keyword">new</span> Object[] {<span class="hljs-string">"name4"</span>});  <br><span class="hljs-comment line-number">11.</span>  Assert.assertEquals(<span class="hljs-number">1</span>, count);  <br><span class="hljs-comment line-number">12.</span>}  <br></code></pre>

<p>通过JdbcTemplate的int update(String sql, PreparedStatementSetter pss)执行预编译sql，其中sql参数为“insert into test(name) values (?) ”，该sql有一个占位符需要在执行前设值，PreparedStatementSetter实现就是为了设值，使用setValues(PreparedStatement pstmt)回调方法设值相应的占位符位置的值。JdbcTemplate也提供一种更简单的方式“update(String sql, Object… args)”来实现设值，所以只要当使用该种方式不满足需求时才应使用PreparedStatementSetter。</p>

<p>3）结果集处理回调：</p>

</div><div id="wmd-preview-section-3095" class="wmd-preview-section preview-content">

<pre class="prettyprint with-line-number hljs-dark"><code class="language-java hljs"><span class="hljs-comment line-number">1.</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testResultSet1</span><span class="hljs-params">()</span> </span>{  <br><span class="hljs-comment line-number">2.</span>  jdbcTemplate.update(<span class="hljs-string">"insert into test(name) values('name5')"</span>);  <br><span class="hljs-comment line-number">3.</span>  String listSql = <span class="hljs-string">"select * from test"</span>;  <br><span class="hljs-comment line-number">4.</span>  List result = jdbcTemplate.query(listSql, <span class="hljs-keyword">new</span> RowMapper&lt;Map&gt;() {  <br><span class="hljs-comment line-number">5.</span>     <span class="hljs-annotation">@Override</span>  <br><span class="hljs-comment line-number">6.</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> Map <span class="hljs-title">mapRow</span><span class="hljs-params">(ResultSet rs, <span class="hljs-keyword">int</span> rowNum)</span> <span class="hljs-keyword">throws</span> SQLException </span>{  <br><span class="hljs-comment line-number">7.</span>          Map row = <span class="hljs-keyword">new</span> HashMap();  <br><span class="hljs-comment line-number">8.</span>          row.put(rs.getInt(<span class="hljs-string">"id"</span>), rs.getString(<span class="hljs-string">"name"</span>));  <br><span class="hljs-comment line-number">9.</span>          <span class="hljs-keyword">return</span> row;  <br><span class="hljs-comment line-number">10.</span>  }});  <br><span class="hljs-comment line-number">11.</span>  Assert.assertEquals(<span class="hljs-number">1</span>, result.size());  <br><span class="hljs-comment line-number">12.</span>  jdbcTemplate.update(<span class="hljs-string">"delete from test where name='name5'"</span>);       <br><span class="hljs-comment line-number">13.</span>}  <br></code></pre>

<p>RowMapper接口提供mapRow(ResultSet rs, int rowNum)方法将结果集的每一行转换为一个Map，当然可以转换为其他类，如表的对象画形式。</p>

</div><div id="wmd-preview-section-3096" class="wmd-preview-section preview-content">

<pre class="prettyprint with-line-number hljs-dark"><code class="language-java hljs"><span class="hljs-comment line-number">1.</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testResultSet2</span><span class="hljs-params">()</span> </span>{  <br><span class="hljs-comment line-number">2.</span>  jdbcTemplate.update(<span class="hljs-string">"insert into test(name) values('name5')"</span>);  <br><span class="hljs-comment line-number">3.</span>  String listSql = <span class="hljs-string">"select * from test"</span>;  <br><span class="hljs-comment line-number">4.</span>  <span class="hljs-keyword">final</span> List result = <span class="hljs-keyword">new</span> ArrayList();  <br><span class="hljs-comment line-number">5.</span>  jdbcTemplate.query(listSql, <span class="hljs-keyword">new</span> RowCallbackHandler() {  <br><span class="hljs-comment line-number">6.</span>      <span class="hljs-annotation">@Override</span>  <br><span class="hljs-comment line-number">7.</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processRow</span><span class="hljs-params">(ResultSet rs)</span> <span class="hljs-keyword">throws</span> SQLException </span>{  <br><span class="hljs-comment line-number">8.</span>          Map row = <span class="hljs-keyword">new</span> HashMap();  <br><span class="hljs-comment line-number">9.</span>          row.put(rs.getInt(<span class="hljs-string">"id"</span>), rs.getString(<span class="hljs-string">"name"</span>));  <br><span class="hljs-comment line-number">10.</span>          result.add(row);  <br><span class="hljs-comment line-number">11.</span>  }});  <br><span class="hljs-comment line-number">12.</span>  Assert.assertEquals(<span class="hljs-number">1</span>, result.size());  <br><span class="hljs-comment line-number">13.</span>  jdbcTemplate.update(<span class="hljs-string">"delete from test where name='name5'"</span>);  <br><span class="hljs-comment line-number">14.</span>}  <br></code></pre>

<p>RowCallbackHandler接口也提供方法processRow(ResultSet rs)，能将结果集的行转换为需要的形式。</p>

</div><div id="wmd-preview-section-3097" class="wmd-preview-section preview-content">

<pre class="prettyprint with-line-number hljs-dark"><code class="language-java hljs"><span class="hljs-comment line-number">1.</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testResultSet3</span><span class="hljs-params">()</span> </span>{  <br><span class="hljs-comment line-number">2.</span>  jdbcTemplate.update(<span class="hljs-string">"insert into test(name) values('name5')"</span>);  <br><span class="hljs-comment line-number">3.</span>  String listSql = <span class="hljs-string">"select * from test"</span>;  <br><span class="hljs-comment line-number">4.</span>  List result = jdbcTemplate.query(listSql, <span class="hljs-keyword">new</span> ResultSetExtractor&lt;List&gt;() {  <br><span class="hljs-comment line-number">5.</span>      <span class="hljs-annotation">@Override</span>  <br><span class="hljs-comment line-number">6.</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> List <span class="hljs-title">extractData</span><span class="hljs-params">(ResultSet rs)</span>  <br><span class="hljs-comment line-number">7.</span>     <span class="hljs-keyword">throws</span> SQLException, DataAccessException </span>{  <br><span class="hljs-comment line-number">8.</span>          List result = <span class="hljs-keyword">new</span> ArrayList();  <br><span class="hljs-comment line-number">9.</span>          <span class="hljs-keyword">while</span>(rs.next()) {  <br><span class="hljs-comment line-number">10.</span>              Map row = <span class="hljs-keyword">new</span> HashMap();  <br><span class="hljs-comment line-number">11.</span>              row.put(rs.getInt(<span class="hljs-string">"id"</span>), rs.getString(<span class="hljs-string">"name"</span>));  <br><span class="hljs-comment line-number">12.</span>              result.add(row);  <br><span class="hljs-comment line-number">13.</span>           }  <br><span class="hljs-comment line-number">14.</span>           <span class="hljs-keyword">return</span> result;  <br><span class="hljs-comment line-number">15.</span>  }});  <br><span class="hljs-comment line-number">16.</span>  Assert.assertEquals(<span class="hljs-number">0</span>, result.size());  <br><span class="hljs-comment line-number">17.</span>  jdbcTemplate.update(<span class="hljs-string">"delete from test where name='name5'"</span>);  <br><span class="hljs-comment line-number">18.</span>}  <br></code></pre>

<p>ResultSetExtractor使用回调方法extractData(ResultSet rs)提供给用户整个结果集，让用户决定如何处理该结果集。</p>

<p>当然JdbcTemplate提供更简单的queryForXXX方法，来简化开发：</p>

</div><div id="wmd-preview-section-3098" class="wmd-preview-section preview-content">

<pre class="prettyprint with-line-number hljs-dark"><code class="language-java hljs"><span class="hljs-comment line-number">1.</span><span class="hljs-comment">//1.查询一行数据并返回int型结果  </span><br><span class="hljs-comment line-number">2.</span>jdbcTemplate.queryForInt(<span class="hljs-string">"select count(*) from test"</span>);  <br><span class="hljs-comment line-number">3.</span><span class="hljs-comment">//2. 查询一行数据并将该行数据转换为Map返回  </span><br><span class="hljs-comment line-number">4.</span>jdbcTemplate.queryForMap(<span class="hljs-string">"select * from test where name='name5'"</span>);  <br><span class="hljs-comment line-number">5.</span><span class="hljs-comment">//3.查询一行任何类型的数据，最后一个参数指定返回结果类型  </span><br><span class="hljs-comment line-number">6.</span>jdbcTemplate.queryForObject(<span class="hljs-string">"select count(*) from test"</span>, Integer.class);  <br><span class="hljs-comment line-number">7.</span><span class="hljs-comment">//4.查询一批数据，默认将每行数据转换为Map       </span><br><span class="hljs-comment line-number">8.</span>jdbcTemplate.queryForList(<span class="hljs-string">"select * from test"</span>);  <br><span class="hljs-comment line-number">9.</span><span class="hljs-comment">//5.只查询一列数据列表，列类型是String类型，列名字是name  </span><br><span class="hljs-comment line-number">10.</span>jdbcTemplate.queryForList(<span class="hljs-string">"  <br><span class="hljs-comment line-number">11.</span>select name from test where name=?"</span>, <span class="hljs-keyword">new</span> Object[]{<span class="hljs-string">"name5"</span>}, String.class);  <br><span class="hljs-comment line-number">12.</span><span class="hljs-comment">//6.查询一批数据，返回为SqlRowSet，类似于ResultSet，但不再绑定到连接上  </span><br><span class="hljs-comment line-number">13.</span>SqlRowSet rs = jdbcTemplate.queryForRowSet(<span class="hljs-string">"select * from test"</span>);  <br></code></pre>

<p>3） 存储过程及函数回调： <br>
首先修改JdbcTemplateTest的setUp方法，修改后如下所示：</p>

</div><div id="wmd-preview-section-3099" class="wmd-preview-section preview-content">

<pre class="prettyprint with-line-number hljs-dark"><code class="language-java hljs"><span class="hljs-comment line-number">1.</span><span class="hljs-annotation">@Before</span>  <br><span class="hljs-comment line-number">2.</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{  <br><span class="hljs-comment line-number">3.</span>    String createTableSql = <span class="hljs-string">"create memory table test"</span> +  <br><span class="hljs-comment line-number">4.</span>    <span class="hljs-string">"(id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, "</span> +  <br><span class="hljs-comment line-number">5.</span>    <span class="hljs-string">"name varchar(100))"</span>;  <br><span class="hljs-comment line-number">6.</span>    jdbcTemplate.update(createTableSql);  <br><span class="hljs-comment line-number">7.</span>    String createHsqldbFunctionSql =  <br><span class="hljs-comment line-number">8.</span>      <span class="hljs-string">"CREATE FUNCTION FUNCTION_TEST(str CHAR(100)) "</span> +  <br><span class="hljs-comment line-number">9.</span>      <span class="hljs-string">"returns INT begin atomic return length(str);end"</span>;  <br><span class="hljs-comment line-number">10.</span>    jdbcTemplate.update(createHsqldbFunctionSql);  <br><span class="hljs-comment line-number">11.</span>    String createHsqldbProcedureSql =  <br><span class="hljs-comment line-number">12.</span>      <span class="hljs-string">"CREATE PROCEDURE PROCEDURE_TEST"</span> +  <br><span class="hljs-comment line-number">13.</span>      <span class="hljs-string">"(INOUT inOutName VARCHAR(100), OUT outId INT) "</span> +  <br><span class="hljs-comment line-number">14.</span>      <span class="hljs-string">"MODIFIES SQL DATA "</span> +  <br><span class="hljs-comment line-number">15.</span>      <span class="hljs-string">"BEGIN ATOMIC "</span> +  <br><span class="hljs-comment line-number">16.</span>      <span class="hljs-string">"  insert into test(name) values (inOutName); "</span> +  <br><span class="hljs-comment line-number">17.</span>      <span class="hljs-string">"  SET outId = IDENTITY(); "</span> +  <br><span class="hljs-comment line-number">18.</span>      <span class="hljs-string">"  SET inOutName = 'Hello,' + inOutName; "</span> +  <br><span class="hljs-comment line-number">19.</span>    <span class="hljs-string">"END"</span>;  <br><span class="hljs-comment line-number">20.</span>    jdbcTemplate.execute(createHsqldbProcedureSql);  <br><span class="hljs-comment line-number">21.</span>}  <br></code></pre>

<pre class="prettyprint with-line-number hljs-dark"><code class="hljs cal"><span class="hljs-comment line-number">1.</span>   其中CREATE FUNCTION FUNCTION_TEST用于创建自定义函数，CREATE <span class="hljs-function"><span class="hljs-keyword">PROCEDURE</span> <span class="hljs-title">PROCEDURE_TEST</span>用于创建存储过程，注意这些创建语句是数据库相关的，本示例中的语句只适用于<span class="hljs-title">HSQLDB</span>数据库。<br><span class="hljs-comment line-number">2.</span><br><span class="hljs-comment line-number">3.</span>   其次修改<span class="hljs-title">JdbcTemplateTest</span>的<span class="hljs-title">tearDown</span>方法，修改后如下所示：</span><br></code></pre>

</div><div id="wmd-preview-section-3100" class="wmd-preview-section preview-content">

<pre class="prettyprint with-line-number hljs-dark"><code class="language-java hljs"><span class="hljs-comment line-number">1.</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tearDown</span><span class="hljs-params">()</span> </span>{  <br><span class="hljs-comment line-number">2.</span>    jdbcTemplate.execute(<span class="hljs-string">"DROP FUNCTION FUNCTION_TEST"</span>);  <br><span class="hljs-comment line-number">3.</span>    jdbcTemplate.execute(<span class="hljs-string">"DROP PROCEDURE PROCEDURE_TEST"</span>);  <br><span class="hljs-comment line-number">4.</span>    String dropTableSql = <span class="hljs-string">"drop table test"</span>;  <br><span class="hljs-comment line-number">5.</span>    jdbcTemplate.execute(dropTableSql);  <br><span class="hljs-comment line-number">6.</span>}  <br></code></pre>

<pre class="prettyprint with-line-number hljs-dark"><code class="hljs rust"><span class="hljs-comment line-number">1.</span>   其中<span class="hljs-built_in">drop</span>语句用于删除创建的存储过程、自定义函数及数据库表。<br><span class="hljs-comment line-number">2.</span><br><span class="hljs-comment line-number">3.</span>   接下来看一下hsqldb如何调用自定义函数：<br></code></pre>

</div><div id="wmd-preview-section-3101" class="wmd-preview-section preview-content">

<pre class="prettyprint with-line-number hljs-dark"><code class="language-java hljs"><span class="hljs-comment line-number">1.</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testCallableStatementCreator1</span><span class="hljs-params">()</span> </span>{  <br><span class="hljs-comment line-number">2.</span>    <span class="hljs-keyword">final</span> String callFunctionSql = <span class="hljs-string">"{call FUNCTION_TEST(?)}"</span>;  <br><span class="hljs-comment line-number">3.</span>    List&lt;SqlParameter&gt; params = <span class="hljs-keyword">new</span> ArrayList&lt;SqlParameter&gt;();  <br><span class="hljs-comment line-number">4.</span>    params.add(<span class="hljs-keyword">new</span> SqlParameter(Types.VARCHAR));  <br><span class="hljs-comment line-number">5.</span>    params.add(<span class="hljs-keyword">new</span> SqlReturnResultSet(<span class="hljs-string">"result"</span>,  <br><span class="hljs-comment line-number">6.</span>       <span class="hljs-keyword">new</span> ResultSetExtractor&lt;Integer&gt;() {  <br><span class="hljs-comment line-number">7.</span>           <span class="hljs-annotation">@Override</span>  <br><span class="hljs-comment line-number">8.</span>           <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">extractData</span><span class="hljs-params">(ResultSet rs)</span> <span class="hljs-keyword">throws</span> SQLException,  <br><span class="hljs-comment line-number">9.</span>               DataAccessException </span>{  <br><span class="hljs-comment line-number">10.</span>               <span class="hljs-keyword">while</span>(rs.next()) {  <br><span class="hljs-comment line-number">11.</span>                   <span class="hljs-keyword">return</span> rs.getInt(<span class="hljs-number">1</span>);  <br><span class="hljs-comment line-number">12.</span>               }  <br><span class="hljs-comment line-number">13.</span>              <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br><span class="hljs-comment line-number">14.</span>       }));  <br><span class="hljs-comment line-number">15.</span>    Map&lt;String, Object&gt; outValues = jdbcTemplate.call(  <br><span class="hljs-comment line-number">16.</span>       <span class="hljs-keyword">new</span> CallableStatementCreator() {  <br><span class="hljs-comment line-number">17.</span>            <span class="hljs-annotation">@Override</span>  <br><span class="hljs-comment line-number">18.</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> CallableStatement <span class="hljs-title">createCallableStatement</span><span class="hljs-params">(Connection conn)</span> <span class="hljs-keyword">throws</span> SQLException </span>{  <br><span class="hljs-comment line-number">19.</span>              CallableStatement cstmt = conn.prepareCall(callFunctionSql);  <br><span class="hljs-comment line-number">20.</span>              cstmt.setString(<span class="hljs-number">1</span>, <span class="hljs-string">"test"</span>);  <br><span class="hljs-comment line-number">21.</span>              <span class="hljs-keyword">return</span> cstmt;  <br><span class="hljs-comment line-number">22.</span>    }}, params);  <br><span class="hljs-comment line-number">23.</span>    Assert.assertEquals(<span class="hljs-number">4</span>, outValues.get(<span class="hljs-string">"result"</span>));  <br><span class="hljs-comment line-number">24.</span>}  <br></code></pre>

<p>{call FUNCTION_TEST(?)}：定义自定义函数的sql语句，注意hsqldb {?= call …}和{call …}含义是一样的，而比如mysql中两种含义是不一样的；</p>

<p>params：用于描述自定义函数占位符参数或命名参数类型；SqlParameter用于描述IN类型参数、SqlOutParameter用于描述OUT类型参数、SqlInOutParameter用于描述INOUT类型参数、SqlReturnResultSet用于描述调用存储过程或自定义函数返回的ResultSet类型数据，其中SqlReturnResultSet需要提供结果集处理回调用于将结果集转换为相应的形式，hsqldb自定义函数返回值是ResultSet类型。</p>

<p>CallableStatementCreator：提供Connection对象用于创建CallableStatement对象</p>

<p>outValues：调用call方法将返回类型为Map&lt;String, Object&gt;对象；</p>

<p>outValues.get(“result”)：获取结果，即通过SqlReturnResultSet对象转换过的数据；其中SqlOutParameter、SqlInOutParameter、SqlReturnResultSet指定的name用于从call执行后返回的Map中获取相应的结果，即name是Map的键。</p>

<p>注：因为hsqldb {?= call …}和{call …}含义是一样的，因此调用自定义函数将返回一个包含结果的ResultSet。</p>

<p>最后让我们示例下mysql如何调用自定义函数：</p>

</div><div id="wmd-preview-section-3102" class="wmd-preview-section preview-content">

<pre class="prettyprint with-line-number hljs-dark"><code class="language-java hljs"><span class="hljs-comment line-number">1.</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testCallableStatementCreator2</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-comment line-number">2.</span>  JdbcTemplate mysqlJdbcTemplate = <span class="hljs-keyword">new</span> JdbcTemplate(getMysqlDataSource);<br><span class="hljs-comment line-number">3.</span>  <span class="hljs-comment">//2.创建自定义函数</span><br><span class="hljs-comment line-number">4.</span>  String createFunctionSql =<br><span class="hljs-comment line-number">5.</span>    <span class="hljs-string">"CREATE FUNCTION FUNCTION_TEST(str VARCHAR(100)) "</span> +<br><span class="hljs-comment line-number">6.</span>    <span class="hljs-string">"returns INT return LENGTH(str)"</span>;<br><span class="hljs-comment line-number">7.</span>  String dropFunctionSql = <span class="hljs-string">"DROP FUNCTION IF EXISTS FUNCTION_TEST"</span>;<br><span class="hljs-comment line-number">8.</span>  mysqlJdbcTemplate.update(dropFunctionSql);<br><span class="hljs-comment line-number">9.</span>  mysqlJdbcTemplate.update(createFunctionSql);<br><span class="hljs-comment line-number">10.</span><span class="hljs-comment">//3.准备sql,mysql支持{?= call …}</span><br><span class="hljs-comment line-number">11.</span>  <span class="hljs-keyword">final</span> String callFunctionSql = <span class="hljs-string">"{?= call FUNCTION_TEST(?)}"</span>;<br><span class="hljs-comment line-number">12.</span><span class="hljs-comment">//4.定义参数</span><br><span class="hljs-comment line-number">13.</span>  List&lt;SqlParameter&gt; params = <span class="hljs-keyword">new</span> ArrayList&lt;SqlParameter&gt;();<br><span class="hljs-comment line-number">14.</span>  params.add(<span class="hljs-keyword">new</span> SqlOutParameter(<span class="hljs-string">"result"</span>, Types.INTEGER));<br><span class="hljs-comment line-number">15.</span>  params.add(<span class="hljs-keyword">new</span> SqlParameter(<span class="hljs-string">"str"</span>, Types.VARCHAR));<br><span class="hljs-comment line-number">16.</span>  Map&lt;String, Object&gt; outValues = mysqlJdbcTemplate.call(<br><span class="hljs-comment line-number">17.</span>  <span class="hljs-keyword">new</span> CallableStatementCreator() {<br><span class="hljs-comment line-number">18.</span>    <span class="hljs-annotation">@Override</span><br><span class="hljs-comment line-number">19.</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> CallableStatement <span class="hljs-title">createCallableStatement</span><span class="hljs-params">(Connection conn)</span> <span class="hljs-keyword">throws</span> SQLException </span>{<br><span class="hljs-comment line-number">20.</span>      CallableStatement cstmt = conn.prepareCall(callFunctionSql);<br><span class="hljs-comment line-number">21.</span>      cstmt.registerOutParameter(<span class="hljs-number">1</span>, Types.INTEGER);<br><span class="hljs-comment line-number">22.</span>      cstmt.setString(<span class="hljs-number">2</span>, <span class="hljs-string">"test"</span>);<br><span class="hljs-comment line-number">23.</span>      <span class="hljs-keyword">return</span> cstmt;<br><span class="hljs-comment line-number">24.</span>    }<br><span class="hljs-comment line-number">25.</span>  }, params);<br><span class="hljs-comment line-number">26.</span>  Assert.assertEquals(<span class="hljs-number">4</span>, outValues.get(<span class="hljs-string">"result"</span>));<br><span class="hljs-comment line-number">27.</span>}<br><span class="hljs-comment line-number">28.</span><span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">getMysqlDataSource</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-comment line-number">29.</span>  String url = <span class="hljs-string">"jdbc:mysql://localhost:3306/test"</span>;<br><span class="hljs-comment line-number">30.</span>  DriverManagerDataSource dataSource = <span class="hljs-keyword">new</span> DriverManagerDataSource(url, <span class="hljs-string">"root"</span>, <span class="hljs-string">""</span>);<br><span class="hljs-comment line-number">31.</span>  dataSource.setDriverClassName(<span class="hljs-string">"com.mysql.jdbc.Driver"</span>);<br><span class="hljs-comment line-number">32.</span>  <span class="hljs-keyword">return</span> dataSource;<br><span class="hljs-comment line-number">33.</span>}<br></code></pre>

<p>getMysqlDataSource：首先启动mysql（本书使用5.4.3版本），其次登录mysql创建test数据库（“create database test;”），在进行测试前，请先下载并添加mysql-connector-java-5.1.10.jar到classpath； <br>
{?= call FUNCTION_TEST(?)}：可以使用{?= call …}形式调用自定义函数； <br>
params：无需使用SqlReturnResultSet提取结果集数据，而是使用SqlOutParameter来描述自定义函数返回值； <br>
CallableStatementCreator：同上个例子含义一样； <br>
cstmt.registerOutParameter(1, Types.INTEGER)：将OUT类型参数注册为JDBC类型Types.INTEGER，此处即返回值类型为Types.INTEGER。 <br>
outValues.get(“result”)：获取结果，直接返回Integer类型，比hsqldb简单多了吧</p>

<p>最后看一下如何如何调用存储过程：</p>

</div><div id="wmd-preview-section-3103" class="wmd-preview-section preview-content">

<pre class="prettyprint with-line-number hljs-dark"><code class="language-java hljs"><span class="hljs-comment line-number">1.</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testCallableStatementCreator3</span><span class="hljs-params">()</span> </span>{  <br><span class="hljs-comment line-number">2.</span>    <span class="hljs-keyword">final</span> String callProcedureSql = <span class="hljs-string">"{call PROCEDURE_TEST(?, ?)}"</span>;  <br><span class="hljs-comment line-number">3.</span>    List&lt;SqlParameter&gt; params = <span class="hljs-keyword">new</span> ArrayList&lt;SqlParameter&gt;();  <br><span class="hljs-comment line-number">4.</span>    params.add(<span class="hljs-keyword">new</span> SqlInOutParameter(<span class="hljs-string">"inOutName"</span>, Types.VARCHAR));  <br><span class="hljs-comment line-number">5.</span>    params.add(<span class="hljs-keyword">new</span> SqlOutParameter(<span class="hljs-string">"outId"</span>, Types.INTEGER));  <br><span class="hljs-comment line-number">6.</span>    Map&lt;String, Object&gt; outValues = jdbcTemplate.call(  <br><span class="hljs-comment line-number">7.</span>      <span class="hljs-keyword">new</span> CallableStatementCreator() {  <br><span class="hljs-comment line-number">8.</span>        <span class="hljs-annotation">@Override</span>  <br><span class="hljs-comment line-number">9.</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> CallableStatement <span class="hljs-title">createCallableStatement</span><span class="hljs-params">(Connection conn)</span> <span class="hljs-keyword">throws</span> SQLException </span>{  <br><span class="hljs-comment line-number">10.</span>          CallableStatement cstmt = conn.prepareCall(callProcedureSql);  <br><span class="hljs-comment line-number">11.</span>          cstmt.registerOutParameter(<span class="hljs-number">1</span>, Types.VARCHAR);  <br><span class="hljs-comment line-number">12.</span>          cstmt.registerOutParameter(<span class="hljs-number">2</span>, Types.INTEGER);  <br><span class="hljs-comment line-number">13.</span>          cstmt.setString(<span class="hljs-number">1</span>, <span class="hljs-string">"test"</span>);  <br><span class="hljs-comment line-number">14.</span>          <span class="hljs-keyword">return</span> cstmt;  <br><span class="hljs-comment line-number">15.</span>    }}, params);  <br><span class="hljs-comment line-number">16.</span>    Assert.assertEquals(<span class="hljs-string">"Hello,test"</span>, outValues.get(<span class="hljs-string">"inOutName"</span>));  <br><span class="hljs-comment line-number">17.</span>    Assert.assertEquals(<span class="hljs-number">0</span>, outValues.get(<span class="hljs-string">"outId"</span>));  <br><span class="hljs-comment line-number">18.</span>}  <br></code></pre>

<p>{call PROCEDURE_TEST(?, ?)}：定义存储过程sql； <br>
params：定义存储过程参数；SqlInOutParameter描述INOUT类型参数、SqlOutParameter描述OUT类型参数； <br>
CallableStatementCreator：用于创建CallableStatement，并设值及注册OUT参数类型； <br>
outValues：通过SqlInOutParameter及SqlOutParameter参数定义的name来获取存储过程结果。</p>

<p>JdbcTemplate类还提供了很多便利方法，在此就不一一介绍了，但这些方法是由规律可循的，第一种就是提供回调接口让用户决定做什么，第二种可以认为是便利方法（如queryForXXX），用于那些比较简单的操作。</p></div><div id="wmd-preview-section-footnotes" class="preview-content"></div></div></body></html>