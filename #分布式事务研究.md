# 分布式事务研究



　　关于分布式事务，笔者推荐的处理方法是“尽量避免”，如果实在避免不了（这已经是高并发、用户量比较多的网站了）则使用“最终一致性”处理（参照CAP理论base思想），如果处理了事务，但还是遇到了数据错误，那还有最后一道保障，那就是“日志”，可以通过日志找回数据，其实大部分互联网公司也都是这么做的。说到“尽量避免”，可能有人认为这不是一个解决问题的办法。这里举个例子，我们生活在城市，其实是每天面临危险的，走路有可能遇到天上掉下的板砖，坐车有可能遇到酒驾，甚至不少人摔个跟头都能淹死，这些低概率的危险我们无法避免。但如果你生活在一个交通事故频发的地段，如果你还有小孩，这个时候你最先想到的解决办法是什么？是提议政府改善公路构造？还是立刻搬走？相信，正常人都会选择搬走，这就是我们所说的“尽量避免”，在微服务应用中如果无休止的创建跨事务服务，那么事务的复杂性也将永无止境，如下图：

![](image/4758-20151102140654289-1511678563.png)

​       这棵服务调用树如果继续延伸下去，相信到了某一时刻，神仙也解决不了出现的问题。其实，即使是数据库本身它们的事务也不是能够百分百保证，就拿Oracle来说，遇到突然停电或宕机照样丢失数据。笔者有一次安装了SAP的一个系统，数据库用的是Oracle，结果一次停电后竟然连表都整个丢失。SAP的系统足够强大了，Oracle也足够强大，当两个复杂的系统相遇，出现的问题将更复杂。每次遇到数据库丢数据，最终解决办法都是看日志找回数据。从这里也可以看出“日志”是事务或者说数据一致性的最后保障。

​       在复杂的服务调用结构中我们遇到的最困难的问题是“并发性”问题。如上图，A、B两个接口同时调用了C接口，如果A、B是同时调用的，如何保证C调用的有序性？假如C就是电子商务中的购买接口，我们知道某商品购买是需要有序执行的，因为每购买一次商品数量会减少。这个时候显然需要为A、B设置一个锁机制，保证A、B接口的调用有序性，比如我们在共享内存中建立A、B的锁：      

　　锁名称A-B   锁值0

​      那么不管什么时候要执行A、B接口都需要来查询锁的值，如果锁的值是0，就修改为1，并执行，执行完后将该锁值修改为0，表示释放该锁。这只是执行成功的情况，如果A、B其中一个执行失败，情况就更复杂了。假设A、B都执行C成功，但A在执行D时失败，那么A需要回滚C的数据，但此时B正在提交C的数据。此时如何处理？此时我们采用“最终一致性”方法，处理的方法就是，你把执行上下文和错误情况作为事件进行“记录和汇报”。记录可以是记录日志，汇报可以是发送消息给消息队列，或者发送给一个专门处理分布式事务错误的处理单元。这很像现实中我们处理问题的方法，比如家里进小偷了，警察来后会这样问：在什么情况下（执行的上下文），你丢了什么（产生了什么调用失败），只有把这些汇报给他后他才能处理。

​      如果是上面这个例子，C代表购买接口，那么你需要发送的数据包括：A在执行C时，C所操作的数据的最初值（上下文数据），以及C最后把数据更新到了什么值（错误信息）。这样分布式事务错误处理单元即使在B提交了事务后也可以对A所操作的C进行回滚，这个回滚方法也要经过编程的，并不是直接恢复某个值那么简单，很可能有复杂的处理逻辑。

​      现在看到了，只是调用树最外层A、B两个服务的调用就如此复杂，那么如果有几百个服务，服务之间又有错综复杂的调用，那情况都不可想象。此时有些情况估计XA分布式事务也无法处理，因为它并不知道执行的上下文，这个上下文是你自己编写，更何况还有一些在XA之外的外部接口，还可能有除数据库之外的其它存储方式包含在事务当中。不过还是可以通过上面我们所说的方法进行处理的，因为再复杂也不可能超过现实中事物的复杂。当然，最好的办法还是我们之前提到的“尽量避免”，那属于防患于未然。要尽量避免可以从以下方面去做（可能不全面）：

*   避免出现循环调用。
*   尽量避免出现并发性调用。
*   服务要分层，上层接口只能调用下层接口。
*   事务强相关性表尽量放同一个库。
*   可以将事务性操作，封装成一个接口，在代码级处理跨库事务。

　　其中1）是要完全避免的，这根我们线程编程一样的，如果出现A调用B，B又调用A，线程是很容易死锁的，对于接口不会出现死锁但会出现数据丢失，而且是毫无蛛丝马迹的丢失。至于5），在代码级处理跨库事务有很多方法，XA就是其中一种，当然因为集群问题（只支持单点部署，无法部署高可用集群），也要慎用。

　　微服务中分布式事务的使用涉及“利益”和|“风险”的关系。利益和风险永远成正比。这里的利益是指：系统的执行性能提升、开发成本减少等，风险是指：数据不一致、性能下降等。分布式事务是减少风险，但又同时减少了利益。所以，这是个要权衡利弊的操作，没有也不会存在一个完美的方案，只会存在一个适用于某种情况下的方案。孢子框架在这里推荐两种轻量级方案：

*   假如有接口C，实现C的回滚接口，A调用C、D，如果C调用成功，D调用失败，A中直接调用C回滚接口。


*   假如有接口C，实现C的回滚接口，A调用C、D，如果C调用成功，D调用失败，A中发送C调用上下文及错误信息到消息队列，消息队列持久化该消息，C监听该消息并调用回滚接口，或者专门的事务失败处理服务监听该消息并调用C的回滚接口。

　很显然1）方案很多种情况会回滚失败，所以它适合于数据一致性要求不是很高的情况，比如删掉一篇留言。分析1）回滚失败有以下几个方面：

*    C服务因高负载宕机
*    C服务所关联数据库宕机
*    C服务因网络原因调用不了
*    C服务本线程死掉

　　其中a比较严重，此时会积累大量的C回滚请求没有处理，所以这种情况下宕机，数据失败的比较多。至于c概率较小，因为前面你已经调用C成功了，说明网络没问题。至于b就概率更小了，而且数据库宕机这种情况一旦发生恐怕后果不仅仅是分布式事务的问题了，这个问题要在数据库方面解决。剩下的d，说明编码逻辑有问题，这就要求提高编码的水平，保证只要不是外设和停电的问题，都能运行正常，需要编程方面的技巧。那么可以看来，只有a才是限制这种方法的最根本原因，所以在并发不是很高的情况下，该方案基本不会出现什么问题。

　　方案2）其实也是很多专家们提到的了。就是先将回滚信息持久化，然后再处理回滚。这种情况也会失败，具体失败原因应该和XA这种分布式方案差不多了，分析如下：

*   停电
*   消息队列不可用（XA的TM不可用）

　　至于b只要使用高可用的消息队列集群就可以避免，或者监控消息队列的执行情况，避免因存储空间不足而宕机。这个方案失败基本是因为停电等一霎那进程失败所导致。比如正在向消息队列发送回滚事件的一霎那停电，比如正在回滚数据时数据库一霎那停电等等。这种进程内失败的问题，任何系统都无法避免，但这毕竟是小概率事件。所以这个方案有着比XA更高可靠性（XA是不能部署集群的）。其实，包括oracle等数据库以及office里面的word等文字处理工具，都是用类似方案处理。比如orcale，他会记录事务里面的每一步操作，如果事务失败它就把这些操作进行反向操作，如果你删除了一条数据，它此时就增加这条数据，如果你修改了某字段，它就把某字段恢复旧值（要记录旧值，这很关键）。所以，这个方案看上去很简单，但回滚处理比较复杂，回滚处理要按业务场景处理，也就是按失败上下文去处理。

## 基础理论

   目前关于事务的几大理论包括：**ACID事务特性，CAP分布式理论，以及BASE**等。**ACID在数据库事务中体现**，**CAP和BASE则是分布式事务的理论**，结合业务系统

### ACID

*ACID*，指数据库事务正确执行的四个基本要素的缩写。包含：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）

### CAP

- C（一致性）一致性是指数据的原子性，在经典的数据库中通过事务来保障，事务完成时，无论成功或回滚，数据都会处于一致的状态，在分布式环境下，一致性是指多个节点数据是否一致；
- A（可用性）服务一直保持可用的状态，当用户发出一个请求，服务能在一定的时间内返回结果；
- P（分区容忍性）在分布式应用中，可能因为一些分布式的原因导致系统无法运转，好的分区容忍性，使应用虽然是一个分布式系统，但是好像一个可以正常运转的整体

### BASE

- BA: Basic Availability 基本业务可用性；
- S: Soft state 柔性状态；
- E: Eventual consistency 最终一致性；



## 2PC

## 2PC

> 二阶段提交(Two-phaseCommit)是指，在计算机网络以及数据库领域内，为了使基于分布式系统架构下的所有节点在进行事务提交时保持一致性而设计的一种算法(Algorithm)。通常，二阶段提交也被称为是一种协议(Protocol))。在分布式系统中，每个节点虽然可以知晓自己的操作时成功或者失败，却无法知道其他节点的操作的成功或失败。当一个事务跨越多个节点时，为了保持事务的ACID特性，需要引入一个作为协调者的组件来统一掌控所有节点(称作参与者)的操作结果并最终指示这些节点是否要把操作结果进行真正的提交(比如将更新后的数据写入磁盘等等)。因此，**二阶段提交的算法思路可以概括为：参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。**

所谓的两个阶段是指：第一阶段：**准备阶段(投票阶段)**和第二阶段：**提交阶段（执行阶段）**。

### 准备阶段

事务协调者(事务管理器)给每个参与者(资源管理器)发送Prepare消息，每个参与者要么直接返回失败(如权限验证失败)，要么在本地执行事务，写本地的redo和undo日志，但不提交，到达一种“万事俱备，只欠东风”的状态。

可以进一步将准备阶段分为以下三个步骤：

> 1）协调者节点向所有参与者节点询问是否可以执行提交操作(vote)，并开始等待各参与者节点的响应。
>
> 2）参与者节点执行询问发起为止的所有事务操作，并将Undo信息和Redo信息写入日志。（注意：若成功这里其实每个参与者已经执行了事务操作）
>
> 3）各参与者节点响应协调者节点发起的询问。如果参与者节点的事务操作实际执行成功，则它返回一个”同意”消息；如果参与者节点的事务操作实际执行失败，则它返回一个”中止”消息。

### 提交阶段

如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(Rollback)消息；否则，发送提交(Commit)消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。(注意:必须在最后阶段释放锁资源)

接下来分两种情况分别讨论提交阶段的过程。

当协调者节点从所有参与者节点获得的相应消息都为”同意”时:

![success](http://www.hollischuang.com/wp-content/uploads/2015/12/success.png)

> 1）协调者节点向所有参与者节点发出”正式提交(commit)”的请求。
>
> 2）参与者节点正式完成操作，并释放在整个事务期间内占用的资源。
>
> 3）参与者节点向协调者节点发送”完成”消息。
>
> 4）协调者节点受到所有参与者节点反馈的”完成”消息后，完成事务。

如果任一参与者节点在第一阶段返回的响应消息为”中止”，或者 协调者节点在第一阶段的询问超时之前无法获取所有参与者节点的响应消息时：

![fail](http://www.hollischuang.com/wp-content/uploads/2015/12/fail.png)

> 1）协调者节点向所有参与者节点发出”回滚操作(rollback)”的请求。
>
> 2）参与者节点利用之前写入的Undo信息执行回滚，并释放在整个事务期间内占用的资源。
>
> 3）参与者节点向协调者节点发送”回滚完成”消息。
>
> 4）协调者节点受到所有参与者节点反馈的”回滚完成”消息后，取消事务。

不管最后结果如何，第二阶段都会结束当前事务。

二阶段提交看起来确实能够提供原子性的操作，但是不幸的事，二阶段提交还是有几个**缺点**的：

> 1、**同步阻塞问题**。执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。
>
> 2、**单点故障**。由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）
>
> 3、**数据不一致**。在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，这回导致只有一部分参与者接受到了commit请求。而在这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。
>
> 4、二阶段无法解决的问题：协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。

由于二阶段提交存在着诸如同步阻塞、单点问题、脑裂等缺陷，所以，研究者们在二阶段提交的基础上做了改进，提出了三阶段提交。

## 3PC

> 三阶段提交（Three-phase commit），也叫三阶段提交协议（Three-phase commit protocol），是二阶段提交（2PC）的改进版本。

![3](http://www.hollischuang.com/wp-content/uploads/2015/12/3.png)

与两阶段提交不同的是，三阶段提交有两个改动点。

1、引入超时机制。同时在协调者和参与者中都引入超时机制。
2、在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。

也就是说，除了引入超时机制之外，3PC把2PC的准备阶段再次一分为二，这样三阶段提交就有`CanCommit`、`PreCommit`、`DoCommit`三个阶段。

### CanCommit阶段

3PC的CanCommit阶段其实和2PC的准备阶段很像。协调者向参与者发送commit请求，参与者如果可以提交就返回Yes响应，否则返回No响应。

> **1.事务询问** 协调者向参与者发送CanCommit请求。询问是否可以执行事务提交操作。然后开始等待参与者的响应。
>
> **2.响应反馈** 参与者接到CanCommit请求之后，正常情况下，如果其自身认为可以顺利执行事务，则返回Yes响应，并进入预备状态。否则反馈No

### PreCommit阶段

协调者根据参与者的反应情况来决定是否可以记性事务的PreCommit操作。根据响应情况，有以下两种可能。

**假如协调者从所有的参与者获得的反馈都是Yes响应，那么就会执行事务的预执行。**

> **1.发送预提交请求** 协调者向参与者发送PreCommit请求，并进入Prepared阶段。
>
> **2.事务预提交** 参与者接收到PreCommit请求后，会执行事务操作，并将undo和redo信息记录到事务日志中。
>
> **3.响应反馈** 如果参与者成功的执行了事务操作，则返回ACK响应，同时开始等待最终指令。

**假如有任何一个参与者向协调者发送了No响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。**

> **1.发送中断请求** 协调者向所有参与者发送abort请求。
>
> **2.中断事务** 参与者收到来自协调者的abort请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断。

### doCommit阶段

该阶段进行真正的事务提交，也可以分为以下两种情况。

**执行提交**

> **1.发送提交请求** 协调接收到参与者发送的ACK响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送doCommit请求。
>
> **2.事务提交** 参与者接收到doCommit请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。
>
> **3.响应反馈** 事务提交完之后，向协调者发送Ack响应。
>
> **4.完成事务** 协调者接收到所有参与者的ack响应之后，完成事务。

**中断事务** 协调者没有接收到参与者发送的ACK响应（可能是接受者发送的不是ACK响应，也可能响应超时），那么就会执行中断事务。

> **1.发送中断请求** 协调者向所有参与者发送abort请求
>
> **2.事务回滚** 参与者接收到abort请求之后，利用其在阶段二记录的undo信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。
>
> **3.反馈结果** 参与者完成事务回滚之后，向协调者发送ACK消息
>
> **4.中断事务** 协调者接收到参与者反馈的ACK消息之后，执行事务的中断。

`在doCommit阶段，如果参与者无法及时接收到来自协调者的doCommit或者rebort请求时，会在等待超时之后，会继续进行事务的提交。（其实这个应该是基于概率来决定的，当进入第三阶段时，说明参与者在第二阶段已经收到了PreCommit请求，那么协调者产生PreCommit请求的前提条件是他在第二阶段开始之前，收到所有参与者的CanCommit响应都是Yes。（一旦参与者收到了PreCommit，意味他知道大家其实都同意修改了）所以，一句话概括就是，当进入第三阶段时，由于网络超时等原因，虽然参与者没有收到commit或者abort响应，但是他有理由相信：成功提交的几率很大。 ）`

## 2PC与3PC的区别

相对于2PC，3PC主要解决的单点故障问题，并减少阻塞，因为一旦参与者无法及时收到来自协调者的信息之后，他会默认执行commit。而不会一直持有事务资源并处于阻塞状态。但是这种机制也会导致数据一致性问题，因为，由于网络原因，协调者发送的abort响应没有及时被参与者接收到，那么参与者在等待超时之后执行了commit操作。这样就和其他接到abort命令并执行回滚的参与者之间存在数据不一致的情况。

------

了解了2PC和3PC之后，我们可以发现，无论是二阶段提交还是三阶段提交都无法彻底解决分布式的一致性问题。Google Chubby的作者Mike Burrows说过， `there is only one consensus protocol, and that’s Paxos” – all other approaches are just broken versions of Paxos.` 意即**世上只有一种一致性算法，那就是Paxos**，所有其他一致性算法都是Paxos算法的不完整版。后面的文章会介绍这个公认为难于理解但是行之有效的Paxos算法。

## 参考资料：

1. [分布式协议之两阶段提交协议（2PC）和改进三阶段提交协议（3PC）](http://www.mamicode.com/info-detail-890945.html)
2. [关于分布式事务、两阶段提交、一阶段提交、Best Efforts 1PC模式和事务补偿机制的研究](http://blog.csdn.net/bluishglc/article/details/7612811)
3. [两阶段提交协议与三阶段提交协议](http://www.solinx.co/archives/392)