#同步容器、并发容器、阻塞队列、双端队列与工作密取
在多线程的开发中经常会碰到数据的并发修改，并发存取，因此正确的使用不同的容器很关键，直接影响到数据的正确性。下面主要记录下三种重要的队列，以及一种非常使用的双端队列。
##同步容器
主要代表有Vector和Hashtable，以及Collections.synchronizedXxx等。
锁的粒度为当前对象整体。
迭代器是及时失败的，即在迭代的过程中发现被修改，就会抛出ConcurrentModificationException。
##并发容器
主要代表有ConcurrentHashMap、CopyOnWriteArrayList、ConcurrentSkipListMap、ConcurrentSkipListSet
锁的粒度是分散的、细粒度的，即读和写是使用不同的锁。
迭代器具有弱一致性，即可以容忍并发修改，不会抛出ConcurrentModificationException。
##阻塞队列
主要代表有LinkedBlockingQueue、ArrayBlockingQueue、PriorityBlockingQueue(Comparable,Comparator)、SynchronousQueue。
提供了可阻塞的put和take方法，以及支持定时的offer和poll方法。
适用于生产者、消费者模式（线程池和工作队列-Executor）
同时也是同步容器
##双端队列和工作密取
主要代表有ArrayDeque和LinkedBlockingDeque。
意义：正如阻塞队列适用于生产者消费者模式，双端队列同样适用与另一种模式，即工作密取。在生产者-消费者设计中，所有消费者共享一个工作队列，而在工作密取中，每个消费者都有各自的双端队列。
如果一个消费者完成了自己双端队列中的全部工作，那么他就可以从其他消费者的双端队列末尾秘密的获取工作。具有更好的可伸缩性，这是因为工作者线程不会在单个共享的任务队列上发生竞争。
在大多数时候，他们都只是访问自己的双端队列，从而极大的减少了竞争。当工作者线程需要访问另一个队列时，它会从队列的尾部而不是头部获取工作，因此进一步降低了队列上的竞争。
适用于：网页爬虫等任务中     