<!DOCTYPE html><html><head><title>java LinkedList ArrayList 随机访问效率 list.get(int index)</title><meta charset='utf-8'><link href='https://dn-maxiang.qbox.me/res-min/themes/marxico.css' rel='stylesheet'><style>
.note-content  {font-family: 'Helvetica Neue', Arial, 'Hiragino Sans GB', STHeiti, 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, Song, sans-serif;}

</style></head><body><div id='preview-contents' class='note-content'>
                        <div id="wmd-preview" class="preview-content"></div>
                    <div id="wmd-preview-section-3270" class="wmd-preview-section preview-content">

</div><div id="wmd-preview-section-3271" class="wmd-preview-section preview-content">

<h1 id="java-linkedlist-arraylist-随机访问效率-listgetint-index">java LinkedList ArrayList 随机访问效率 list.get(int index)</h1>

<p>理论上来说，肯定LinkedList比ArrayList随机访问效率要低，然后LinkedList比ArrayList插入删除元素要快。</p>

<p>突然想起之前写一个日记本程序，是用LinkedList+Map索引，作为数据库。Map记录了LinkedList中每一个日记的index和日期之间的对应关系。从Map中获取到某个日期对应日记的index，然后再去LinkedList，get(index)。</p>

<p>复制代码 <br>
        Integer a = 1; <br>
        LinkedList list = new LinkedList(); <br>
        for (int i = 0; i &lt; 2000000; i++) { <br>
            list.add(a); <br>
        } <br>
        System.out.println(list.size()); <br>
        long start = System.nanoTime(); <br>
        list.get(1000000); <br>
        long end = System.nanoTime(); <br>
        System.out.println(end - start); <br>
复制代码 <br>
上边一段代码，看出了几样事情：</p>

<p>1.LinkedList的随机访问速度确实差点，大概用了17毫秒。下边会贴出LinkedList随机访问的源代码，也就是这里为什么选择1000000中间数的原因。</p>

<p>2.Java栈区和堆区都是有限的，list那里如果一次添加5000000个item就会内存溢出</p>

<pre class="prettyprint with-line-number hljs-dark"><code class="hljs stylus"><span class="hljs-comment line-number">1.</span>（Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">"main"</span> java<span class="hljs-class">.lang</span><span class="hljs-class">.OutOfMemoryError</span>: Java heap space）。<br><span class="hljs-comment line-number">2.</span><br><span class="hljs-comment line-number">3.</span> 但有点奇怪，不是new了在内存堆区吗？内存堆区也会爆~~<br></code></pre>

<p>下边是LinkedList随机访问的源代码，采取了折半的遍历方式，每个循环里边进行一次int的比较。</p>

<p>复制代码 <br>
    private Entry entry(int index) { <br>
        if (index &lt; 0 || index &gt;= size) <br>
            throw new IndexOutOfBoundsException(“Index: “+index+ <br>
                                                “, Size: “+size); <br>
        Entry e = header; <br>
        if (index &lt; (size &gt;&gt; 1)) { <br>
            for (int i = 0; i &lt;= index; i++) <br>
                e = e.next; <br>
        } else { <br>
            for (int i = size; i &gt; index; i–) <br>
                e = e.previous; <br>
        } <br>
        return e; <br>
    } <br>
复制代码</p>

<p>换了ArrayList的话，添加5000000个item都不会爆，但再大点，还是会爆~~</p>

<p>随机访问效率确实高很多，只需要16微秒左右，足足快了1千倍，而且跟get的index无关。</p></div><div id="wmd-preview-section-footnotes" class="preview-content"></div></div></body></html>